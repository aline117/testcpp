#include <netinet/in.h>#include <arpa/inet.h>#include <thread>#include <unistd.h>#include <string>#include "uLog.h"#include "strUtil.h"#include "udp_connect.h"//void hander_client(int svrPort,const sockaddr_in& addrClient, const std::string& msg) {void hander_client(int id,int svrPort,const std::string&sAddr, const std::string& msg) {    sockaddr_in addrClient;    memcpy(&addrClient,(char*)sAddr.data(), sizeof(addrClient));    int fd;    if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {        perror("socket");        exit(EXIT_FAILURE);    }    /*设置socket属性，端口可以重用*/    int opt = SO_REUSEADDR;    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));    setsockopt(fd,SOL_SOCKET,  SO_REUSEPORT, &opt, sizeof(opt));    //KEY bind server ip&port with fd    int ret;    struct sockaddr_in local_addr;    bzero(&local_addr, sizeof(local_addr));    local_addr.sin_family = PF_INET;    local_addr.sin_port = htons(svrPort);    local_addr.sin_addr.s_addr = INADDR_ANY;    if ((ret=bind(fd, (struct sockaddr *) &local_addr, sizeof(struct sockaddr))) == -1) {        perror("bind");        exit(1);    }    //KEY connect remote client with fd    if ((ret=connect(fd, (const struct sockaddr *) &addrClient, sizeof(struct sockaddr_in))) == -1) {        perror("connect");        exit(1);    }    LIF("\t accept id:%d ip:%s:%d msg:'%s' connect:fd:%d ret:%d",id,inet_ntoa(addrClient.sin_addr), ntohs(addrClient.sin_port),STR(msg),fd,ret);    ssize_t len =0;    std::string sLog;    int count=1;    char szBuf[BUFSZ + 1];    msg.copy(szBuf,BUFSZ);    bool bLoop = true;    while (bLoop) {        //LIF("\t fd:%d recv:'%s'",fd,szBuf);        sLog = SUtil::Format("id:%03d/%04d/fd:%d[back:%s]",id,count,fd,szBuf);        ++count;        len = send(fd, STR(sLog), sLog.size(), 0);        LIF("\t fd:%3d send len:%d/'%s'",fd,len,STR(sLog));        bzero(&szBuf, sizeof(szBuf));        len = recv(fd, szBuf, BUFSZ, 0);        if (len <= 0) {            //LER("\t %d",len);            sLog.clear();            continue;        }        szBuf[len]='\0';        if(0==strncmp("exit",szBuf,4)){            bLoop = false;            continue;        }    }    LIF("over........");    printf("wait connect ...\n");}int main(int argc, char*args[]) {    LIF("cmd: %s %d", args[0], argc);    int fdSvrListener;    int port = PORT;    if (argc > 1) {        int p = atoi(args[1]);        if (p > 0 && p != port) {            port = p;        }    }    //create socket    if ((fdSvrListener = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {        perror("socket");        exit(EXIT_FAILURE);    }    //reuse addr/port    int opt = 1;    setsockopt(fdSvrListener, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));    setsockopt(fdSvrListener, SOL_SOCKET, SO_REUSEPORT, &opt, sizeof(opt));    //bind server ip&port    sockaddr_in svr_addr;    bzero(&svr_addr, sizeof(svr_addr));    svr_addr.sin_family = AF_INET;    svr_addr.sin_port = htons(port);    svr_addr.sin_addr.s_addr = INADDR_ANY;    if (bind(fdSvrListener, (struct sockaddr *) &svr_addr, sizeof(svr_addr)) == -1) {        perror("bind");        exit(2);    }    socklen_t addrLen = sizeof(svr_addr);    LIF("server begin to listen:%d", port);    int id=1;    char szBuf[BUFSZ + 1];    bool bLoop = true;    while (bLoop) {        sockaddr_in addrClient;        ssize_t len = recvfrom(fdSvrListener, szBuf, BUFSZ, 0, (struct sockaddr *) &addrClient, &addrLen);        if (len > 0) {            szBuf[len]='\0';        }        printf("\n");        LIF("main loop id:%d msg:%d/'%s'",id, len, szBuf);        //char hbuf[NI_MAXHOST], sbuf[NI_MAXSERV];        //ret = getnameinfo((struct sockaddr *)&client_addr, addr_size, hbuf, sizeof(hbuf), sbuf, sizeof(sbuf), NI_NUMERICHOST | NI_NUMERICSERV);        //check(ret == 0, "getnameinfo");        std::string sMsg(szBuf);        std::string sAddr;        sAddr.reserve(sizeof(addrClient) + 2);        sAddr.resize(sizeof(addrClient));        memcpy((char *)sAddr.data(),&addrClient,sizeof(addrClient));        std::thread([addrClient,sAddr, sMsg,id,port]() {            //hander_client(port, addrClient, sMsg);            hander_client(id,port, sAddr, sMsg);        }).detach();        ++id;    }    return 0;}