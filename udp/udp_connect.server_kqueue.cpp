#include <netinet/in.h>#include <arpa/inet.h>#include <sys/event.h>#include <thread>#include <unistd.h>#include <string>#include "uLog.h"#include "strUtil.h"#include "udp_connect.h"int updateEvents(int efd, int fd, int events,int id, bool bDel) {    struct kevent ev[3];    int n = 0;    intptr_t ud = id;    if (events & kReadEvent) {        EV_SET(&ev[n++], fd, EVFILT_READ, EV_ADD | EV_ENABLE, 0, 0, (void *) ud);        if (bDel) {            EV_SET(&ev[n++], fd, EVFILT_READ, EV_DELETE, 0, 0, (void *) ud);        }    }    if (events & kWriteEvent) {        EV_SET(&ev[n++], fd, EVFILT_WRITE, EV_ADD | EV_ENABLE, 0, 0, (void *) ud);        if (bDel) {            EV_SET(&ev[n++], fd, EVFILT_WRITE, EV_DELETE, 0, 0, (void *) fd);        }    }    int r = kevent(efd, ev, n, NULL, 0, NULL);    //exit_if(r, "kevent failed ");    //LIE(!r,"kevent %s",strerror(errno));    LIE(!r,"kevent %s fd %d events:%d read %d write %d ret:%d", (bDel?"del":"add"), fd,events, events & kReadEvent, events & kWriteEvent,r);    return r;}void handleRead(int id,int efd, int fd) {    ssize_t len =0;    char szBuf[BUFSZ + 1];    bzero(&szBuf, sizeof(szBuf));    len = recv(fd, szBuf, BUFSZ, 0);    if (len <= 0) {        //LER("\t %d",len);        //sLog.clear();        //continue;        if (len < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {            LWN("recv: ret:%d errno:%d",len,errno);            return;        }    }    szBuf[len]='\0';    if(0==strncmp("exit",szBuf,4)){        LIF("fd:%d exit ...",fd);        close(fd);        updateEvents(efd, fd, kReadEvent | kWriteEvent,id, true);    }    std::string sLog = SUtil::Format("id:%d fd:%d[back:%s]",id,fd,szBuf);    len = send(fd, STR(sLog), sLog.size(), 0);    LIF("\t id:%d fd:%3d send len:%d/'%s'",id,fd,len,STR(sLog));}void handleAccept(int id,int efd, int fdListener,int svrPort) {    socklen_t addrLen = sizeof(socklen_t);    char szBuf[BUFSZ + 1]={0};    sockaddr_in addrClient;    ssize_t len = recvfrom(fdListener, szBuf, BUFSZ, 0, (struct sockaddr *) &addrClient, &addrLen);    if (len > 0) {        szBuf[len]='\0';    }    printf("\n");    LIF("main loop id:%d msg:%d/'%s'",id, len, szBuf);    int fd;    if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {        perror("socket");        exit(EXIT_FAILURE);    }    /*设置socket属性，端口可以重用*/    int opt = SO_REUSEADDR;    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));    setsockopt(fd,SOL_SOCKET,  SO_REUSEPORT, &opt, sizeof(opt));    setNonBlock(fd);    //KEY bind server ip&port with fd    int ret;    struct sockaddr_in local_addr;    bzero(&local_addr, sizeof(local_addr));    local_addr.sin_family = PF_INET;    local_addr.sin_port = htons(svrPort);    local_addr.sin_addr.s_addr = INADDR_ANY;    if ((ret=bind(fd, (struct sockaddr *) &local_addr, sizeof(struct sockaddr))) == -1) {        perror("bind");        exit(1);    }    //KEY connect remote client with fd    if ((ret=connect(fd, (const struct sockaddr *) &addrClient, sizeof(struct sockaddr_in))) == -1) {        perror("connect");        exit(1);    }    LIF("\t accept id:%d ip:%s:%d msg:'%s' connect:fd:%d ret:%d",id,inet_ntoa(addrClient.sin_addr), ntohs(addrClient.sin_port),szBuf,fd,ret);    //updateEvents(efd, fd, kReadEvent | kWriteEvent, false);    updateEvents(efd, fd, kReadEvent,id, false);    //send    std::string sLog = SUtil::Format("fd:%d[back:%s]",fd,szBuf);    len = send(fd, STR(sLog), sLog.size(), 0);    LIF("\t id:%d fd:%3d send len:%d/'%s'",id,fd,len,STR(sLog));}int main(int argc, char*args[]) {    LIF("cmd: %s %d", args[0], argc);    int fdSvrListener;    int port = PORT;    if (argc > 1) {        int p = atoi(args[1]);        if (p > 0 && p != port) {            port = p;        }    }    int epollfd = kqueue();    if (epollfd < 0) {        perror("kqueue");        exit(2);    }    //create socket    if ((fdSvrListener = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {        perror("socket");        exit(EXIT_FAILURE);    }    //reuse addr/port    int opt = 1;    setsockopt(fdSvrListener, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));    setsockopt(fdSvrListener, SOL_SOCKET, SO_REUSEPORT, &opt, sizeof(opt));    setNonBlock(fdSvrListener);    //bind server ip&port    sockaddr_in svr_addr;    bzero(&svr_addr, sizeof(svr_addr));    svr_addr.sin_family = AF_INET;    svr_addr.sin_port = htons(port);    svr_addr.sin_addr.s_addr = INADDR_ANY;    if (bind(fdSvrListener, (struct sockaddr *) &svr_addr, sizeof(svr_addr)) == -1) {        perror("bind");        exit(2);    }    updateEvents(epollfd, fdSvrListener, kReadEvent,0, false);    LIF("server begin to listen:%d fd:%d", port,fdSvrListener);    int id = 1;    char szBuf[BUFSZ + 1];    bool bLoop = true;    while (bLoop) {        int waitms = 10 * 1000; //10ms        struct timespec timeout;        timeout.tv_sec = waitms / 1000;        timeout.tv_nsec = (waitms % 1000) * 1000 * 1000;        const int kMaxEvents = 100;        struct kevent activeEvs[kMaxEvents];        int n = kevent(epollfd, NULL, 0, activeEvs, kMaxEvents, &timeout);        //LIF("epoll_wait return %d", n);        for (int i = 0; i < n; i++) {            //int fd = (int) (intptr_t) activeEvs[i].udata;            int fd = (int) (intptr_t) activeEvs[i].ident;            int events = activeEvs[i].filter;            if (events == EVFILT_READ) {                if (fd == fdSvrListener) {                    handleAccept(id++,epollfd, fd, port);                } else {                    int iid = (intptr_t)activeEvs[i].udata;                    handleRead(iid,epollfd, fd);                }            } else if (events == EVFILT_WRITE) {                LIF("------handleWrite fd:%d",fd);                //updateEvents(epollfd, fd, kReadEvent, true);                //handleWrite(epollfd, fd);            } else {                LER("unknown event fd:%d ev:%d",fd, events);                //exit_if(1, "unknown event");            }        }    }    return 0;}